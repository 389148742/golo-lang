// ............................................................................................. //

options {
  MULTI=true;
  VISITOR=true;
  STATIC=false;
  NODE_CLASS="GoloASTNode";
  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = true;
}

// ............................................................................................. //

PARSER_BEGIN(GoloParser)

package fr.insalyon.citi.golo.compiler.parser;

import java.util.List;
import java.util.LinkedList;
import java.util.Collections;

public class GoloParser {

  public static class ParserClassRef {

    public String name;

    public ParserClassRef(String name) {
      this.name = name;
    }

    @Override
    public String toString() {
      return "Class<" + name + ">";
    }
  }

  public static void main(String[] args) throws Throwable {
    GoloParser parser = new GoloParser(System.in);    
    // ASTCompilationUnit unit = parser.CompilationUnit();
    ASTFunctionDeclaration unit = parser.FunctionDeclaration();
    unit.dump("% ");
  }
}

PARSER_END(GoloParser)

// ............................................................................................. //

// White space
SKIP :
{
  " "
  | "\t"
  | "\r"
  | "\f"
}

TOKEN :
{
  < NEWLINE: "\n" >
}

// Escaping
SKIP :
{
  < ESCAPE: "`" > : ESCAPED
}

// Keywords
TOKEN :
{
  < MODULE: "module" >
  |
  < IMPORT: "import" >
  |
  < FUNCTION: "function" >
  |
  < LOCAL: "local" >
  |
  < RETURN: "return" >
  |
  < IF: "if" >
  |
  < ELSE: "else" >
  |
  < WHILE: "while" >
  |
  < FOR: "for" >
  |
  < FOREACH: "foreach">
  |
  < IN: "in" >
  |
  < THROW: "throw" >
  |
  < TRY: "try" >
  |
  < CATCH: "catch" >
  |
  < FINALLY: "finally" >
  |
  < CASE: "case" >
  |
  < WHEN: "when" >
  |
  < MATCH: "match" >
  |
  < THEN: "then" >
  |
  < OTHERWISE: "otherwise" >
}

// Operators
TOKEN :
{
  < ASSOCIATIVE_OPERATOR: ("*" | "/" | "%" |
                           "<" | "<=" | "==" | "!=" | ">" | ">=" | 
                           "is" | "isnt" |
                           "oftype" ) >
  |
  < COMMUTATIVE_OPERATOR: ("+" | "-" |
                           "and" | "or") >
  |
  < UNARY_OPERATOR: "not" >
}

// References
TOKEN :
{
  < VAR: "var" >
  |
  < LET: "let" >
}

// Literals
TOKEN :
{
  < NUMBER: ("-")? ["0"-"9"] (["0"-"9"])* >
  |
  < LONG_NUMBER: <NUMBER> "_L" >
  |
  < FLOATING_NUMBER: ("-")? (["0"-"9"])+ ("." (["0"-"9"])+)? ("e" (["0"-"9"])+)? >
  |
  < FLOAT: <FLOATING_NUMBER> "_F" >
  |
  < STRING: "\"" (~["\n", "\r", "\""])* "\"" >
  |
  < CHAR: "'" (~["\n", "\r", "\""]) "'" >
  |
  < NULL: "null" >
  |
  < TRUE: "true" >
  |
  < FALSE: "false" >
  |
  < CLASSREF: <IDENTIFIER> ("." <IDENTIFIER>)* ".class" >
}

// Identifiers
<DEFAULT,ESCAPED>
TOKEN :
{
  < IDENTIFIER: <LETTER> (<ID_REST>)* > : DEFAULT
  |
  < #LETTER: [ "A"-"Z", "a"-"z", "_", "$" ] >
  |
  < #ID_REST: [ "A"-"Z", "a"-"z", "_", "$", "0"-"9" ] >
}

// Comments
SPECIAL_TOKEN :
{
  < COMMENT: "#" (~["\n", "\r"])* ("\n" | "\r" | "\r\n") >
}

// ............................................................................................. //

void BlankLines() #void: {}
{
  ( <NEWLINE> )*
}

String QualifiedName() #void:
{
  Token rootToken;
  Token nextToken;
  StringBuilder nameBuilder;
}
{
  rootToken=<IDENTIFIER>
  {
    nameBuilder = new StringBuilder(rootToken.image);
  }
  (
    "." nextToken=<IDENTIFIER>
    {
      nameBuilder.append(".").append(nextToken.image);
    }
  )*
  {
    return nameBuilder.toString();
  }
}

List<String> Arguments() #void:
{
  Token rootToken;
  Token nextToken;
  List<String> arguments = new LinkedList<String>();
}
{
  rootToken=<IDENTIFIER>
  {
    arguments.add(rootToken.image);
  }
  (
    "," (<NEWLINE>)? nextToken=<IDENTIFIER>
    {
      arguments.add(nextToken.image);
    }
  )*
  {
    return arguments;
  }
}

String StringLiteral() #void:
{
  Token literal;
}
{
  literal=<STRING>
  {
    return literal.image.replace("\"", "");
  }
}

Character CharLiteral() #void:
{
  Token literal;
}
{
  literal=<CHAR>
  {
    return Character.valueOf(literal.image.charAt(1));
  }
}

Long LongLiteral() #void:
{
  Token literal;
}
{
  literal=<LONG_NUMBER>
  {
    return Long.valueOf(literal.image.substring(0, literal.image.length() - 2));
  }
}

Integer IntegerLiteral() #void:
{
  Token literal;
}
{
  literal=<NUMBER>
  {
    return Integer.valueOf(literal.image);
  }
}

GoloParser.ParserClassRef ClassLiteral() #void:
{
  Token literal;
}
{
  literal=<CLASSREF>
  {
    String image = literal.image;
    return new GoloParser.ParserClassRef(image.substring(0, image.length() - 6));
  }
}

Double DoubleLiteral() #void:
{
  Token literal;
}
{
  literal=<FLOATING_NUMBER>
  {
    return Double.valueOf(literal.image);
  }
}

Float FloatLiteral() #void:
{
  Token literal;
}
{
  literal=<FLOAT>
  {
    return Float.valueOf(literal.image.substring(0, literal.image.length() - 2));
  }
}

// ............................................................................................. //

ASTCompilationUnit CompilationUnit(): {}
{
  BlankLines()
  ModuleDeclaration()
  BlankLines()
  ( ImportDeclaration() BlankLines() )*
  ( FunctionDeclaration() BlankLines() )*
  <EOF>  
  { return jjtThis; }
}

void ModuleDeclaration():
{
  Token token;
  String name;
}
{
  token=<MODULE> name=QualifiedName()
  {
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
    jjtThis.setName(name);
  }
}

void ImportDeclaration():
{
  Token token;
  String name;
}
{
  token=<IMPORT> name=QualifiedName()
  {
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
    jjtThis.setName(name);
  }
}

ASTFunctionDeclaration FunctionDeclaration():
{
  Token token;
  Token name;
  Token local = null;
}
{
  (local=<LOCAL>)?
  {
    if (local != null) {
      jjtThis.setLocal(true);
    }
  }
  token=<FUNCTION> name=<IDENTIFIER> "=" Function()
  {
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
    jjtThis.setName(name.image);
    return jjtThis;
  }
}

// ............................................................................................. //

void Statement() #void:{}
{
  <NEWLINE> 
  |
  LOOKAHEAD(2) Assignment()
  |
  ExpressionStatement()
  | 
  Return() 
  |
  LetOrVar()
  |
  ConditionalBranching()
  |
  WhileLoop()
  |
  ForLoop()
  |
  ForEachLoop()
  |
  Throw()
  |
  TryCatchFinally()
  |
  Case()
}

void Throw():
{
  Token token;
}
{
  token=<THROW> ExpressionStatement()
  {
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
  }
}

void WhileLoop():
{
  Token token;
}
{
  token=<WHILE> ExpressionStatement() "{" Block() "}"
  {
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
  }
}

void ForLoop():
{
  Token token;
}
{
  token=<FOR> "(" LetOrVar() "," ExpressionStatement() "," Statement() ")" "{" Block() "}"
  {
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
  }
}

void ForEachLoop():
{
  Token token;
  Token elementId;
}
{
  token=<FOREACH> "(" elementId=<IDENTIFIER> <IN> ExpressionStatement() ")" "{" Block() "}"
  {
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
    jjtThis.setElementIdentifier(elementId.image);
  }
}

void TryCatchFinally():
{
  Token token;
  Token exceptionId;
}
{
  token=<TRY> "{" Block() "}" 
  (
    (
      <FINALLY> "{" Block() "}"
      {
        jjtThis.setExceptionId(null);
        jjtThis.setLineInSourceCode(token.beginLine);
        jjtThis.setColumnInSourceCode(token.beginColumn);
      }
    )
    |
    (
      <CATCH> "(" exceptionId=<IDENTIFIER> ")" "{" Block() "}"
      (<FINALLY> "{" Block() "}")?
      {
        jjtThis.setExceptionId(exceptionId.image);
        jjtThis.setLineInSourceCode(token.beginLine);
        jjtThis.setColumnInSourceCode(token.beginColumn);
      }
    )
  )
}

void ExpressionStatement() #void: {}
{
  CommutativeExpression() 
}

void TerminalExpression() #void: {}
{
  LOOKAHEAD(2) FunctionInvocation()
  |
  LOOKAHEAD(2) Reference()
  |
  Match()
  |
  Literal()
  |
  Function()
}

void UnaryExpression():
{
  Token token;
}
{
  token=<UNARY_OPERATOR> CommutativeExpression()
  {
    jjtThis.setOperator(token.image);
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
  }
}

void CommutativeExpression():
{
  Token token;
}
{
  AssociativeExpression()
  (
    LOOKAHEAD(2) token=<COMMUTATIVE_OPERATOR> AssociativeExpression()
    {
      jjtThis.addOperator(token.image);
      jjtThis.addLine(token.beginLine);
      jjtThis.addColumn(token.beginColumn);
    }
  )*
}

void AssociativeExpression():
{
  Token token;
}
{
  (
    "(" CommutativeExpression() ")"
    |
    TerminalExpression()
    |
    UnaryExpression()
  )
  (
    LOOKAHEAD(2)
    (
      token=<ASSOCIATIVE_OPERATOR> AssociativeExpression()
      {
        jjtThis.addOperator(token.image);
        jjtThis.addLine(token.beginLine);
        jjtThis.addColumn(token.beginColumn);
      }
    |
      token=":" (<NEWLINE>)? MethodInvocation()
      {
        jjtThis.addOperator(token.image);
        jjtThis.addLine(token.beginLine);
        jjtThis.addColumn(token.beginColumn);
      }
    )
  )*
}

void MethodInvocation():
{
  Token token;
}
{
  token=<IDENTIFIER> "(" (Expressions())? ")"
  {
    jjtThis.setName(token.image);
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
  }
}


void Block(): {}
{
  (Statement())*
}

void Function():
{
  Token token;
  List<String> arguments = null;
  Token varargsToken = null;
  boolean compactForm = false;
}
{
  ("|" arguments=Arguments() (varargsToken="...")? "|")? 
  (
    (token="{" Block() "}")
    |
    (token="->" ExpressionStatement())
    {
      compactForm = true;
    }
  )
  {
    if (arguments == null) {
      arguments = Collections.emptyList();
    }
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
    jjtThis.setCompactForm(compactForm);
    jjtThis.setArguments(arguments);
    jjtThis.setVarargs(varargsToken != null);
  }
}

void Literal():
{
  Object value;
}
{
  (
    value=ClassLiteral()
    {
      jjtThis.setLiteralValue(value);
    }
    |
    value=StringLiteral()
    {
      jjtThis.setLiteralValue(value);
    }
    |
    value=CharLiteral()
    {
      jjtThis.setLiteralValue(value);
    }
    |
    value=FloatLiteral()
    {
      jjtThis.setLiteralValue(value);
    }
    |
    value=DoubleLiteral()
    {
      jjtThis.setLiteralValue(value);
    }
    |
    value=LongLiteral()
    {
      jjtThis.setLiteralValue(value);
    }
    |
    value=IntegerLiteral()
    {
      jjtThis.setLiteralValue(value);
    }
    |
    <NULL>
    {
      jjtThis.setLiteralValue(null);
    }
    |
    <TRUE>
    {
      jjtThis.setLiteralValue(Boolean.TRUE);
    }
    |
    <FALSE>
    {
      jjtThis.setLiteralValue(Boolean.FALSE);
    }    
  )
}

void Reference():
{
  Token token;
}
{
  token=<IDENTIFIER>
  {
    jjtThis.setName(token.image);
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
  }
}

void LetOrVar():
{
  Token idToken;
}
{
  <LET> idToken=<IDENTIFIER> "=" ExpressionStatement()
  {
    jjtThis.setType(ASTLetOrVar.Type.LET);
    jjtThis.setName(idToken.image);
    jjtThis.setLineInSourceCode(idToken.beginLine);
    jjtThis.setColumnInSourceCode(idToken.beginColumn);
  }
  |
  <VAR> idToken=<IDENTIFIER> "=" ExpressionStatement()
  {
    jjtThis.setType(ASTLetOrVar.Type.VAR);
    jjtThis.setName(idToken.image);
    jjtThis.setLineInSourceCode(idToken.beginLine);
    jjtThis.setColumnInSourceCode(idToken.beginColumn);
  }
}

void Assignment():
{
  Token idToken;
}
{
  idToken=<IDENTIFIER> "=" ExpressionStatement()
  {
    jjtThis.setName(idToken.image);
    jjtThis.setLineInSourceCode(idToken.beginLine);
    jjtThis.setColumnInSourceCode(idToken.beginColumn);
  }
}

void Return():
{
  Token token;
}
{  
  token=<RETURN> (LOOKAHEAD(2) ExpressionStatement())?
  {
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
  }
}

void Expressions() #void: {}
{
  ExpressionStatement() ("," (<NEWLINE>)? ExpressionStatement())*
}

void FunctionInvocation():
{
  String name;
  Token token;
}
{
  name=QualifiedName() token="(" (Expressions())? ")"
  {
    jjtThis.setName(name);
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
  }
}

void ConditionalBranching():
{
  Token token;
}
{
  token=<IF> ExpressionStatement() "{" Block() "}"
  ( LOOKAHEAD( <ELSE> )
    <ELSE>
    (
      ConditionalBranching()
     |
      ( "{" Block() "}" )
    )
  )?
  {
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
  }
}

void Case():
{ 
  Token token;
}
{
  token=<CASE> "{" (<NEWLINE>)?
    ( <WHEN> ExpressionStatement() "{" Block() "}" (<NEWLINE>)? )+
    <OTHERWISE> "{" Block() "}" (<NEWLINE>)?
  "}"
  {
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
  }
}

void Match():
{ 
  Token token;
}
{
  token=<MATCH> "{" (<NEWLINE>)?
    ( <WHEN> ExpressionStatement() <THEN> ExpressionStatement() (<NEWLINE>)? )+
    <OTHERWISE> ExpressionStatement() (<NEWLINE>)?
  "}"
  {
    jjtThis.setLineInSourceCode(token.beginLine);
    jjtThis.setColumnInSourceCode(token.beginColumn);
  }
}

// ............................................................................................. //
