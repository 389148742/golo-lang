== Decorators ==

Golo feature Python-like decorators.

=== Presentation ===

Decorators are similar in syntax and purpose to Java annotations.
However, the concepts behind them are very different. Indeed, whereas Java
annotations are compiler or VM directives, decorators are actually plain
functions, more precisely higher order functions. 

NOTE: Higher order functions are functions that process functions, i.e. that take a
function as parameter, and may return a new function.

A decorator is thus a function that take the function to decorate as parameter,
and return a new function, generally a wrapper that do some stuffs before or
after calling the original function.

To be the most generic, a decorator should be a variable arity function, and
thus call the decorated function with `invokeWithArguments`.

The name can remind the well known 
http://en.wikipedia.org/wiki/Decorator_pattern[GoF pattern], with good reason.
This pattern describe a design that allow an object to be augmented by wrapping
it in an other object with the same interface, delegating operations to the
wrapped object. This is exactly what a decorator does here, the interface
being "function".


=== Principles and Syntax ===

As in Python, and similarly to Java annotations, a decorator is used with a
`@` prefix before the function definition. As an example, the decorator
`deco1` only prints its name before returning the result unchanged

[source,golo]
----
function deco1 = |fun| {
    return |args...| {
        print("deco1 + ")
        return fun: invokeWithArguments(args)
    }
}
----

It can be used as:

[source,golo]
----
@deco1
function foo = |a| {
    return "foo: " + a
}
----

Here, calling `println(foo(1))` will print `deco1 + foo: 1`.

As illustrated, the decorator is just a wrapper (closure) around the decorated
function. The `@` syntax is just syntactic sugar. Indeed, it can also be used
as such:

[source,golo]
----
function bar = |a| -> "bar: " + a

function main = |args| {
    println(deco1(^bar)(1))

    let decobar = deco1(^bar)
    println(decobar(1))

    println(deco1(|a| -> "bar: "+a)(1))
}
----

prints all `deco1 + bar: 1`.

Decorator can also be stacked. For instance:

[source,golo]
----
function deco2 = |fun| {
    return |args...| {
        print("deco2 + ")
        return fun: invokeWithArguments(args)
    }
}

@deco2
@deco1
function baz = |a| -> "baz: " + a
----

`println(baz(1))` will print `deco2 + deco1 + baz: 1`


Moreover, since decorator are just higher order functions, they can be closure
on a first argument, as illustrated in the following listing:

[source,golo]
----
module testdeco

function log = |msg| {
    return |fun| {
        return |args...| {
            println(msg)
            return fun: invokeWithArguments(args)
        }
    }
}

@log("calling foo")
function foo = |a| {
    println("foo got a " + a)
}

@log("I'am a bar")
function bar = |a| -> 2*a

function main = |args| {
    foo("bar")
    println(bar(21))
}
----

will print 

----
calling foo
foo got a bar
I'am a bar
42
----

Here, `log` create a closure on the message, and return the decorator function.
Thus, `log("hello")` is a function that take a function as parameter, and
return a new function printing the message (`hello`) before delegating to the
inner function.

=== Use Cases and Examples ===

* Aspect oriented programming
* pre/post conditions checking
* memoize
* logging
* locking
* generic wrapper of a function (context)



=== Under the hood ===

(Implementation) Useful? If so, TBD by @artpej


=== Performance issues ===

